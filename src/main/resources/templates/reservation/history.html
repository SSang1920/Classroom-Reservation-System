<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
  <th:block th:replace="~{fragments/common :: common-resources}"></th:block>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <title>예약 이력 보기</title>
</head>
<body>
<div th:replace="~{fragments/topbar :: topbar}"></div>

<div class="container mt-4">
  <h2>📝 예약 이력 보기</h2>

  <div id="no-reservations-message" class="alert alert-info mt-3 d-none" role="alert">
    예약 내역이 없습니다.
  </div>

  <div id="reservations-container" class="table-responsive mt-3">
    <table class="table table-hover text-center">
      <thead class="table-light">
      <tr>
        <th scope="col">#</th>
        <th scope="col">강의실</th>
        <th scope="col">예약 날짜</th>
        <th scope="col">예약 시간</th>
        <th scope="col">상태</th>
        <th scope="col">동작</th>
      </tr>
      </thead>
      <tbody id="reservation-tbody">
      <tr>
        <td colspan="6" class="p-5">
          <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
          </div>
        </td>
      </tr>
      </tbody>
    </table>
  </div>
</div>

<div class="modal fade" id="changeRequestModal" tabindex="-1" aria-labelledby="changeRequestModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="changeRequestModalLabel">예약 변경 요청</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="changeRequestForm">
          <!-- API 호출에 필요한 예약 ID를 임시 저장하는 숨겨진 필드 -->
          <input type="hidden" id="modalReservationId">

          <div class="mb-3">
            <label for="newBuildingId" class="form-label">변경할 건물</label>
            <select class="form-select" id="newBuildingId" required>
              <option value="" selected disabled>건물을 먼저 선택하세요</option>
            </select>
          </div>

          <div class="mb-3">
            <label for="newClassroomId" class="form-label">변경할 강의실</label>
            <select class="form-select" id="newClassroomId" required>
              <option value="" selected disabled>강의실을 선택하세요</option>
            </select>
          </div>
          <div class="mb-3">
            <label for="newReservationDate" class="form-label">변경할 날짜</label>
            <input type="text" class="form-control" id="newReservationDate" required disabled>
          </div>
          <div class="mb-3">
            <label class="form-label">변경할 시간</label>
            <div id="newPeriods" class="d-flex flex-wrap border rounded p-2" style="gap: 0.5rem;">
              <small class="text-muted">강의실과 날짜를 선택하면 예약 가능한 시간이 표시됩니다.</small>
            </div>
            <div id="periods-error" class="invalid-feedback d-block"></div>
          </div>
          <div class="mb-3">
            <label for="requestMessage" class="form-label">요청 메시지 (선택)</label>
            <textarea class="form-control" id="requestMessage" rows="3" placeholder="관리자에게 전달할 메시지를 입력하세요."></textarea>
          </div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">닫기</button>
        <button type="button" class="btn btn-primary" id="submitChangeRequest">요청 제출</button>
      </div>
    </div>
  </div>
</div>

<th:block th:replace="~{fragments/common :: common-scripts}"></th:block>
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
<script src="https://npmcdn.com/flatpickr/dist/l10n/ko.js"></script>
<th:block th:replace="~{fragments/topbar :: topbar-script}"></th:block>


<script>
  // 페이지 로드 시 내 예약 목록을 가져오는 함수를 실행합니다.
  document.addEventListener('DOMContentLoaded', function() {
     fetchMyReservations();
     initializeChangeRequestModal();
   });

  // API를 호출하여 내 예약 목록을 가져오는 비동기 함수
  async function fetchMyReservations() {
      const token = localStorage.getItem('accessToken');
      const tbody = document.getElementById('reservation-tbody');
      const container = document.getElementById('reservations-container');
      const noDataMessage = document.getElementById('no-reservations-message');

      // 토큰이 없으면 로그인 페이지로 되돌려 보냄
      if (!token) {
          alert('로그인이 필요합니다. 로그인 페이지로 이동합니다.');
          window.location.href = '/login';
          return;
      }

      try {
          // /api/reservations/me 엔드포인트에 GET 요청을 보냅니다.
          const response = await fetch('/api/reservations/me', {
              headers: { 'Authorization': `Bearer ${token}` }
          });

          if (!response.ok) {
              const errorData = await response.json();
              throw new Error(errorData.message || '예약 내역을 불러오는 데 실패했습니다.');
          }

          const result = await response.json();
          const reservations = result.data; // ApiSuccessResponse의 data 필드

          // 예약 데이터가 있는지 확인
          if (reservations && reservations.length > 0) {
              container.classList.remove('d-none');
              noDataMessage.classList.add('d-none');
              tbody.innerHTML = ''; // 로딩 스피너 제거
              // 각 예약에 대해 테이블 행을 생성하고 추가합니다.
              reservations.forEach((reservation, index) => {
                  tbody.innerHTML += createReservationRow(reservation, index + 1);
              });
          } else {
              // 예약 데이터가 없으면 '내역 없음' 메시지를 표시합니다.
              container.classList.add('d-none');
              noDataMessage.classList.remove('d-none');
          }
      } catch (error) {
          // 에러 발생 시 에러 메시지를 테이블에 표시합니다.
          tbody.innerHTML = `<tr><td colspan="6" class="text-danger p-4">${error.message}</td></tr>`;
      }
  }

  // 상태 이름에 맞는 Bootstrap 배지를 생성하는 헬퍼 함수
function getStateBadge(state) {
      const states = {
          '예약됨': 'bg-primary',
          '사용 완료': 'bg-success',
          '취소됨': 'bg-secondary',
          '관리자에 의해 취소됨': 'bg-danger',
          '관리자에 의해 변경됨': 'bg-warning text-dark',
          '자동 완료됨': 'bg-info text-dark',
          '요청에 의해 변경됨': 'bg-info text-dark'
      };
      const badgeClass = states[state] || 'bg-dark';
      return `<span class="badge ${badgeClass}">${state}</span>`;
  }

  // 예약 데이터로 테이블의 한 행(<tr>)을 생성하는 함수
function createReservationRow(reservation, count) {
      const startTime = new Date(reservation.startTime);
      const endTime = new Date(reservation.endTime);
      const date = startTime.toLocaleDateString('ko-KR');
      const time = `${startTime.getHours().toString().padStart(2, '0')}:${startTime.getMinutes().toString().padStart(2, '0')} ~ ${endTime.getHours().toString().padStart(2, '0')}:${endTime.getMinutes().toString().padStart(2, '0')}`;
      const stateBadge = getStateBadge(reservation.state);

      let actionButtons = '';
      const now = new Date();
      const actionableStates = ['예약됨', '관리자에 의해 변경됨', '요청에 의해 변경됨'];

      if (actionableStates.includes(reservation.state)) {
          // 1. 취소 버튼 추가
          actionButtons += `
              <button type="button" class="btn btn-sm btn-outline-danger" onclick="handleCancelClick(this, ${reservation.id})">
                  취소
              </button>
          `;

          // 2. '변경 요청' 버튼을 올바른 if/else 구조와 백틱(`)으로 생성
          if (reservation.hasPendingChangeRequest) {
              // PENDING 요청이 있으면 비활성화된 '요청 처리중' 버튼을 표시
              actionButtons += `
                  <button type="button" class="btn btn-sm btn-secondary ms-1" disabled title="이미 처리 대기 중인 요청이 있습니다.">
                      요청 처리중
                  </button>
              `;
          } else {
              // PENDING 요청이 없으면 활성화된 '변경 요청' 버튼을 표시
              actionButtons += `
                  <button type="button" class="btn btn-sm btn-warning ms-1"
                          data-bs-toggle="modal"
                          data-bs-target="#changeRequestModal"
                          data-reservation-id="${reservation.id}">
                      변경 요청
                  </button>
              `;
          }

          // 3. 사용 완료 버튼 (시작 시간 이후에만 표시)
          if (now >= startTime) {
              actionButtons += `
                  <button type="button" class="btn btn-sm btn-outline-success ms-1" onclick="handleCompleteClick(this, ${reservation.id})">
                      사용 완료
                  </button>
              `;
          }
      }

      // 최종적으로 생성된 HTML 반환 (백틱(`) 사용)
      return `
          <tr>
            <th scope="row">${count}</th>
            <td>${reservation.classroomName}</td>
            <td>${date}</td>
            <td>${time}</td>
            <td>${stateBadge}</td>
            <td>${actionButtons || '-'}</td>
          </tr>
      `;
  }

  // 예약 취소 버튼 클릭을 처리하는 비동기 함수
  async function handleCancelClick(button, reservationId) {
      if (!confirm('정말로 예약을 취소하시겠습니까?')) return;

      const token = localStorage.getItem('accessToken');
      const url = `/api/reservations/${reservationId}/cancel`;

      try {
          const response = await fetch(url, {
              method: 'PATCH',
              headers: { 'Authorization': `Bearer ${token}` }
          });

          const result = await response.json();
          if (!response.ok) throw new Error(result.message || '취소에 실패했습니다.');

          // 성공 시, 페이지 새로고침 없이 UI를 직접 업데이트
          const row = button.closest('tr');
          if (row) {
              row.cells[4].innerHTML = getStateBadge('사용자 취소');
              row.cells[5].innerHTML = '-'; // 모든 버튼 제거
          }
      } catch (error) {
          console.error('취소 처리 중 에러 발생:', error);
          alert(error.message);
      }
  }

  // 예약 사용 완료 버튼 클릭을 처리하는 비동기 함수
  async function handleCompleteClick(button, reservationId) {
      if (!confirm('해당 예약을 사용 완료 처리하시겠습니까?')) return;

      const token = localStorage.getItem('accessToken');
      const url = `/api/reservations/${reservationId}/complete`;

      try {
          const response = await fetch(url, {
              method: 'PATCH',
              headers: { 'Authorization': `Bearer ${token}` }
          });

          const result = await response.json();
          if (!response.ok) throw new Error(result.message || '사용 완료 처리에 실패했습니다.');

          // 성공 시, UI를 직접 업데이트
          const row = button.closest('tr');
          if (row) {
              row.cells[4].innerHTML = getStateBadge('사용 완료');
              row.cells[5].innerHTML = '-'; // 모든 버튼 제거
          }
      } catch (error) {
          console.error('사용 완료 처리 중 에러 발생:', error);
          alert(error.message);
      }
  }

  // 예약 변경 요청 모달을 위한 JavaScript 로직
  function initializeChangeRequestModal() {
    const modalEl = document.getElementById('changeRequestModal');
    const form = document.getElementById('changeRequestForm');
    const buildingSelect = document.getElementById('newBuildingId');
    const classroomSelect = document.getElementById('newClassroomId');
    const dateInput = document.getElementById('newReservationDate');
    const periodsDiv = document.getElementById('newPeriods');
    const submitBtn = document.getElementById('submitChangeRequest');
    const token = localStorage.getItem('accessToken');

    periodsDiv.addEventListener('change', function(event) {
        // 이벤트가 체크박스에서 발생했는지 확인
        if (event.target.type === 'checkbox') {
            const checkedBoxes = periodsDiv.querySelectorAll('input[type="checkbox"]:checked');
            if (checkedBoxes.length > 2) {
                alert('시간은 최대 2개까지만 선택할 수 있습니다.');
                event.target.checked = false; // 3번째 선택된 체크박스를 해제
            }
        }
    });

    //  flatpickr 초기화
    const datePicker = flatpickr(dateInput, {
        dateFormat: "Y-m-d",
        altInput: true,
        altFormat: "Y-m-d (D)",
        locale: "ko",
        minDate: "today", // 과거 날짜 선택 불가
        onChange: function(selectedDates, dateStr, instance) {
            fetchAvailableTimes(); // 날짜 변경 시 시간 조회 함수 호출
        }
    });

    // 모달이 열릴 때 실행되는 이벤트
    modalEl.addEventListener('show.bs.modal', async function (event) {
      form.reset();
      classroomSelect.innerHTML = '<option value="" selected disabled>건물을 먼저 선택하세요</option>';
      classroomSelect.disabled = true;
      datePicker.clear(); // 날짜 초기화
      dateInput.disabled = true; // 날짜 선택 비활성화
      if (datePicker.altInput) datePicker.altInput.disabled = true;
      periodsDiv.innerHTML = '<small class="text-muted">건물, 강의실, 날짜를 선택하면 예약 가능한 시간이 표시됩니다.</small>';
      document.getElementById('periods-error').textContent = '';

      const button = event.relatedTarget;
      const reservationId = button.getAttribute('data-reservation-id');
      document.getElementById('modalReservationId').value = reservationId;

      await populateBuildingSelect();
    });

    // 건물 목록을 가져와 select 태그에 채우는 함수
    async function populateBuildingSelect() {
      try {
        const response = await fetch('/api/facilities/buildings', {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (!response.ok) throw new Error('건물 목록 로딩 실패');
        const result = await response.json();
        const buildings = result.data;

        buildingSelect.innerHTML = '<option value="" selected disabled>건물을 선택하세요</option>';
        buildings.forEach(b => {
          buildingSelect.innerHTML += `<option value="${b.id}">${b.name}</option>`;
        });
      } catch (error) {
        console.error(error);
        buildingSelect.innerHTML = `<option value="">${error.message}</option>`;
      }
    }

    // 건물 선택 시, 해당 건물의 강의실 목록을 불러온다.
    buildingSelect.addEventListener('change', async function() {
      const buildingId = this.value;
      classroomSelect.disabled = true;
      classroomSelect.innerHTML = '<option value="">불러오는 중...</option>';
      datePicker.clear();
      dateInput.disabled = true;
      if (datePicker.altInput) datePicker.altInput.disabled = true;
      periodsDiv.innerHTML = '<small class="text-muted">강의실과 날짜를 선택하세요.</small>';

      if (!buildingId) return;

      try {
        const response = await fetch(`/api/facilities/buildings/${buildingId}/classrooms`, {
          headers: { 'Authorization': `Bearer ${token}` }
        });
        if (!response.ok) throw new Error('강의실 목록 로딩 실패');
        const result = await response.json();
        const classrooms = result.data;

        classroomSelect.innerHTML = '<option value="" selected disabled>강의실을 선택하세요</option>';
        classrooms.forEach(c => {
          classroomSelect.innerHTML += `<option value="${c.id}">${c.name}</option>`;
        });
        classroomSelect.disabled = false;
      } catch (error) {
        console.error(error);
        classroomSelect.innerHTML = `<option value="">${error.message}</option>`;
      }
    });

    // 강의실 선택 시 날짜 선택기 활성화
    classroomSelect.addEventListener('change', function() {
        datePicker.clear();
        const isDisabled = !this.value;
        dateInput.disabled = isDisabled;
        if (datePicker.altInput) datePicker.altInput.disabled = isDisabled;
        periodsDiv.innerHTML = '<small class="text-muted">날짜를 선택해주세요.</small>';
    });

    // 예약 가능한 시간대를 가져와 체크박스로 표시하는 함수
  async function fetchAvailableTimes() {
       const classroomId = classroomSelect.value;
       const date = dateInput.value;
       const reservationId = document.getElementById('modalReservationId').value;

       if (!classroomId || !date) {
         periodsDiv.innerHTML = '<small class="text-muted">강의실과 날짜를 선택하세요.</small>';
         return;
       }

       periodsDiv.innerHTML = '<div class="d-flex justify-content-center"><div class="spinner-border spinner-border-sm" role="status"><span class="visually-hidden">Loading...</span></div></div>';

       const allPeriods = [
         { value: 'PERIOD_1', text: '1교시 (09:30 ~ 10:45)', endTime: '10:45' },
         { value: 'PERIOD_2', text: '2교시 (11:00 ~ 12:15)', endTime: '12:15' },
         { value: 'PERIOD_3', text: '3교시 (13:00 ~ 14:15)', endTime: '14:15' },
         { value: 'PERIOD_4', text: '4교시 (14:30 ~ 15:45)', endTime: '15:45' },
         { value: 'PERIOD_5', text: '5교시 (16:00 ~ 17:15)', endTime: '17:15' },
         { value: 'PERIOD_6', text: '6교시 (17:30 ~ 18:45)', endTime: '18:45' },
         { value: 'PERIOD_7', text: '7교시 (19:00 ~ 20:15)', endTime: '20:15' },
         { value: 'PERIOD_8', text: '8교시 (20:30 ~ 21:45)', endTime: '21:45' }
       ];

       try {
         const url = `/api/reservations/classroom/${classroomId}/reserved-periods?date=${date}`;
         const response = await fetch(url, {
           headers: { 'Authorization': `Bearer ${token}` }
         });
         if (!response.ok) throw new Error('시간 조회에 실패했습니다.');

         const result = await response.json();
         const reservedPeriods = new Set(result.data);

         periodsDiv.innerHTML = '';

         const now = new Date();
         const todayStr = now.getFullYear() + '-' + String(now.getMonth() + 1).padStart(2, '0') + '-' + String(now.getDate()).padStart(2, '0');
         const isToday = (date === todayStr);

         allPeriods.forEach(period => {
           const isReserved = reservedPeriods.has(period.value);
           let isPast = false;

           if (isToday) {
             const periodEndTime = new Date(`${date}T${period.endTime}`);
             if (now > periodEndTime) {
               isPast = true;
             }
           }

           const formCheckDiv = document.createElement('div');
           formCheckDiv.className = 'form-check';

           const checkbox = document.createElement('input');
           checkbox.type = 'checkbox';
           checkbox.className = 'form-check-input';
           checkbox.value = period.value;
           checkbox.id = `period-${period.value}`;
           checkbox.disabled = isReserved || isPast;

           const label = document.createElement('label');
           label.className = 'form-check-label';
           label.htmlFor = `period-${period.value}`;

           let labelText = period.text;
           if (isReserved) {
             labelText += " (예약됨)";
           } else if (isPast) {
             labelText += " (시간 지남)";
           }
           label.textContent = labelText;

           formCheckDiv.appendChild(checkbox);
           formCheckDiv.appendChild(label);
           periodsDiv.appendChild(formCheckDiv);
         });

       } catch (error) {
         console.error(error);
         periodsDiv.innerHTML = `<small class="text-danger">${error.message}</small>`;
       }
     }

    // '요청 제출' 버튼 클릭 이벤트
    submitBtn.addEventListener('click', async function () {
      const errorDiv = document.getElementById('periods-error');
      const reservationId = document.getElementById('modalReservationId').value;
      const selectedPeriods = Array.from(document.querySelectorAll('#newPeriods input:checked')).map(cb => cb.value);

      // 유효성 검사
      if (!buildingSelect.value || !classroomSelect.value || !dateInput.value || selectedPeriods.length === 0) {
        errorDiv.textContent = '건물, 강의실, 날짜, 시간을 모두 선택해야 합니다.';
        return;
      }
      errorDiv.textContent = '';

      const requestData = {
        newClassroomId: classroomSelect.value,
        newReservationDate: dateInput.value,
        newPeriods: selectedPeriods,
        requestMessage: document.getElementById('requestMessage').value
      };

      try {
        const response = await fetch(`/api/reservations/${reservationId}/change-requests`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify(requestData)
        });

        const result = await response.json();

        if (response.ok) {
          alert(result.message);
          window.location.reload();
        } else {
          alert(`오류: ${result.message}`);
        }
      } catch (error) {
        console.error('Error:', error);
        alert('요청 중 오류가 발생했습니다.');
      }
    });
  }
</script>

</body>
</html>