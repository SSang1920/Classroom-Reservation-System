<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
  <th:block th:replace="~{fragments/common :: common-resources}"></th:block>
  <title>예약 이력 보기</title>
</head>
<body>
<div th:replace="~{fragments/topbar :: topbar}"></div>

<div class="container mt-4">
  <h2>📝 예약 이력 보기</h2>

  <div id="no-reservations-message" class="alert alert-info mt-3 d-none" role="alert">
    예약 내역이 없습니다.
  </div>

  <div id="reservations-container" class="table-responsive mt-3">
    <table class="table table-hover text-center">
      <thead class="table-light">
      <tr>
        <th scope="col">#</th>
        <th scope="col">강의실</th>
        <th scope="col">예약 날짜</th>
        <th scope="col">예약 시간</th>
        <th scope="col">상태</th>
        <th scope="col">동작</th>
      </tr>
      </thead>
      <tbody id="reservation-tbody">
      <tr>
        <td colspan="6" class="p-5">
          <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
          </div>
        </td>
      </tr>
      </tbody>
    </table>
  </div>
</div>

<th:block th:replace="~{fragments/common :: common-scripts}"></th:block>

<th:block th:replace="~{fragments/topbar :: topbar-script}"></th:block>


<script>
  // 페이지 로드 시 내 예약 목록을 가져오는 함수를 실행합니다.
  document.addEventListener('DOMContentLoaded', fetchMyReservations);

  // API를 호출하여 내 예약 목록을 가져오는 비동기 함수
  async function fetchMyReservations() {
      const token = localStorage.getItem('accessToken');
      const tbody = document.getElementById('reservation-tbody');
      const container = document.getElementById('reservations-container');
      const noDataMessage = document.getElementById('no-reservations-message');

      // 토큰이 없으면 로그인 페이지로 되돌려 보냄
      if (!token) {
          alert('로그인이 필요합니다. 로그인 페이지로 이동합니다.');
          window.location.href = '/login';
          return;
      }

      try {
          // /api/reservations/me 엔드포인트에 GET 요청을 보냅니다.
          const response = await fetch('/api/reservations/me', {
              headers: { 'Authorization': `Bearer ${token}` }
          });

          if (!response.ok) {
              const errorData = await response.json();
              throw new Error(errorData.message || '예약 내역을 불러오는 데 실패했습니다.');
          }

          const result = await response.json();
          const reservations = result.data; // ApiSuccessResponse의 data 필드

          // 예약 데이터가 있는지 확인
          if (reservations && reservations.length > 0) {
              container.classList.remove('d-none');
              noDataMessage.classList.add('d-none');
              tbody.innerHTML = ''; // 로딩 스피너 제거
              // 각 예약에 대해 테이블 행을 생성하고 추가합니다.
              reservations.forEach((reservation, index) => {
                  tbody.innerHTML += createReservationRow(reservation, index + 1);
              });
          } else {
              // 예약 데이터가 없으면 '내역 없음' 메시지를 표시합니다.
              container.classList.add('d-none');
              noDataMessage.classList.remove('d-none');
          }
      } catch (error) {
          // 에러 발생 시 에러 메시지를 테이블에 표시합니다.
          tbody.innerHTML = `<tr><td colspan="6" class="text-danger p-4">${error.message}</td></tr>`;
      }
  }

  // 상태 이름에 맞는 Bootstrap 배지를 생성하는 헬퍼 함수
  function getStateBadge(state) {
      const states = {
          '예약됨': 'bg-primary',
          '사용 완료': 'bg-success',
          '취소됨': 'bg-secondary',
          '관리자에 의해 취소됨': 'bg-danger',
          '관리자에 의해 변경됨': 'bg-warning text-dark',
          '자동 완료됨': 'bg-info text-dark'
      };
      const badgeClass = states[state] || 'bg-dark';
      return `<span class="badge ${badgeClass}">${state}</span>`;
  }

  // 예약 데이터로 테이블의 한 행(<tr>)을 생성하는 함수
  function createReservationRow(reservation, count) {
      const startTime = new Date(reservation.startTime);
      const endTime = new Date(reservation.endTime);
      const date = startTime.toLocaleDateString('ko-KR');
      const time = `${startTime.getHours().toString().padStart(2, '0')}:${startTime.getMinutes().toString().padStart(2, '0')} ~ ${endTime.getHours().toString().padStart(2, '0')}:${endTime.getMinutes().toString().padStart(2, '0')}`;

      //상태 배지 생성 로직을 헬퍼 함수로 분리
      const stateBadge = getStateBadge(reservation.state);

      // 상태에 따라 '취소' 및 '사용 완료' 버튼을 동적으로 생성
      let actionButtons = '';
      const now = new Date();
      const cancellableStates = ['예약됨', '관리자에 의해 변경됨'];

      if (cancellableStates.includes(reservation.state)) {
          actionButtons += `
              <button type="button" class="btn btn-sm btn-outline-danger" onclick="handleCancelClick(this, ${reservation.id})">
                  취소
              </button>
          `;
          // 시작 시간 이후이고, 아직 완료되지 않은 예약에 '사용 완료' 버튼 표시
          if (now >= startTime) {
              actionButtons += `
                  <button type="button" class="btn btn-sm btn-outline-success ms-1" onclick="handleCompleteClick(this, ${reservation.id})">
                      사용 완료
                  </button>
              `;
          }
      }

      return `
          <tr>
            <th scope="row">${count}</th>
            <td>${reservation.classroomName}</td>
            <td>${date}</td>
            <td>${time}</td>
            <td>${stateBadge}</td>
            <td>${actionButtons || '-'}</td>
          </tr>
      `;
  }

  // 예약 취소 버튼 클릭을 처리하는 비동기 함수
  async function handleCancelClick(button, reservationId) {
      if (!confirm('정말로 예약을 취소하시겠습니까?')) return;

      const token = localStorage.getItem('accessToken');
      const url = `/api/reservations/${reservationId}/cancel`;

      try {
          const response = await fetch(url, {
              method: 'PATCH',
              headers: { 'Authorization': `Bearer ${token}` }
          });

          const result = await response.json();
          if (!response.ok) throw new Error(result.message || '취소에 실패했습니다.');

          // 성공 시, 페이지 새로고침 없이 UI를 직접 업데이트
          const row = button.closest('tr');
          if (row) {
              row.cells[4].innerHTML = getStateBadge('사용자 취소');
              row.cells[5].innerHTML = '-'; // 모든 버튼 제거
          }
      } catch (error) {
          console.error('취소 처리 중 에러 발생:', error);
          alert(error.message);
      }
  }

  // 예약 사용 완료 버튼 클릭을 처리하는 비동기 함수
  async function handleCompleteClick(button, reservationId) {
      if (!confirm('해당 예약을 사용 완료 처리하시겠습니까?')) return;

      const token = localStorage.getItem('accessToken');
      const url = `/api/reservations/${reservationId}/complete`;

      try {
          const response = await fetch(url, {
              method: 'PATCH',
              headers: { 'Authorization': `Bearer ${token}` }
          });

          const result = await response.json();
          if (!response.ok) throw new Error(result.message || '사용 완료 처리에 실패했습니다.');

          // 성공 시, UI를 직접 업데이트
          const row = button.closest('tr');
          if (row) {
              row.cells[4].innerHTML = getStateBadge('사용 완료');
              row.cells[5].innerHTML = '-'; // 모든 버튼 제거
          }
      } catch (error) {
          console.error('사용 완료 처리 중 에러 발생:', error);
          alert(error.message);
      }
  }
</script>

</body>
</html>