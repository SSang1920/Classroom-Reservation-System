<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<body>

<div th:fragment="topbar" class="top-bar bg-white border-bottom shadow-sm">

    <style>
        /* 알림 드롭다운 전체 목록 스타일 */
        #notification-list .dropdown-item {
            /*  내용이 길어지면 자동으로 줄바꿈되도록 설정 */
            white-space: normal !important;
            word-wrap: break-word;

            /*  각 알림 항목의 상하 여백을 늘려 가독성 확보 */
            padding-top: 0.75rem;
            padding-bottom: 0.75rem;
        }

        /* 각 알림 항목 사이에 구분선 추가 (마지막 항목 제외) */
        #notification-list li:not(:last-child) {
            border-bottom: 1px solid #e9ecef;
        }

        /*  메시지 텍스트와 시간 텍스트의 정렬을 개선 */
        #notification-list .d-flex > div:first-child {
            /* 메시지 영역이 가능한 많은 공간을 차지하도록 함 */
            flex-grow: 1;
        }
        #notification-list .d-flex > small:last-child {
            /* 시간 영역이 줄어들지 않도록 함 */
            flex-shrink: 0;
            padding-left: 0.5rem; /* 메시지와의 최소 간격 */
        }
    </style>

    <div>
        <a href="/" class="navbar-brand">
            <strong>🎓 강의실 예약 시스템</strong>
        </a>
    </div>

    <div class="d-flex align-items-center">
        <!-- 로그아웃 상태일 때 보여질 뷰 -->
        <div id="logged-out-view">
            <a href="/login" class="btn btn-primary">로그인</a>
            <a href="/signup" class="btn btn-secondary ms-2">회원가입</a>
        </div>

        <!-- 로그인 상태일 때 보여질 뷰 -->
        <div id="logged-in-view" class="d-flex align-items-center d-none">
            <!-- 동적으로 생성 -->
        </div>
    </div>
</div>


<script th:fragment="topbar-script">
    // 읽지 않은 알림 개수를 추적하는 전역 변수
    let unreadCount = 0;

    document.addEventListener('DOMContentLoaded', function() {
        const token = localStorage.getItem('accessToken');
        const loggedOutView = document.getElementById('logged-out-view');
        const loggedInView = document.getElementById('logged-in-view');

        if (token) {
            // UI 상태 변경
            loggedOutView.classList.add('d-none');
            loggedInView.classList.remove('d-none');

            try {
                const payload = parseJwt(token);

                let adminButtonHtml = '';
                if (payload.role === 'ROLE_ADMIN') {
                    adminButtonHtml = `<a href="/admin/main" class="btn btn-warning btn-sm me-2">관리자 페이지</a>`;
                }

                loggedInView.innerHTML = `
                    <span class="me-2">환영합니다, <strong id="username-display">${payload.name || '사용자'}</strong>님!</span>
                    <a href="/mypage" class="btn btn-outline-info btn-sm me-2">내 정보</a>
                    ${adminButtonHtml}
                    <button id="logout-button" class="btn btn-outline-danger btn-sm">로그아웃</button>

                    <div class="notification dropdown ms-2">
                        <button class="btn btn-outline-secondary btn-sm position-relative" type="button" id="notification-dropdown-btn" data-bs-toggle="dropdown" aria-expanded="false">
                        🔔
                        <span class="position-absolute top-0 start-100 translate-middle badge rounded-pill bg-danger d-none" id="notification-count-badge">
                            0
                        </span>
                        </button>
                        <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="notification-dropdown-btn" id="notification-list" style="width: 350px; max-height: 400px; overflow-y: auto;">
                            <!-- 알림 헤더: '모두 읽음' 버튼 포함 -->
                            <li>
                                <div class="dropdown-header d-flex justify-content-between align-items-center px-3 py-2">
                                    <h6 class="mb-0">알림</h6>
                                    <button class="btn btn-link btn-sm p-0" id="mark-all-as-read-btn" style ="text-decoration : none;">모두 읽음</button>
                                </div>
                            </li>
                            <li><hr class="dropdown-divider my-0"></li>
                            <!-- 알림이 없을 때 표시될 메시지 -->
                            <li><p class="dropdown-item text-center text-muted mb-0">알림이 없습니다.</p></li>
                        </ul>
                    </div>
                `;

                document.getElementById('logout-button').addEventListener('click', () => logout(true));
                document.getElementById('mark-all-as-read-btn').addEventListener('click', handleMarkAllAsRead);

                // 로그인 상태일 때만 알림 기능 자동 실행
                initializeNotifications();
                connectSSE();

            } catch (e) {
                console.error("토큰 파싱 오류:", e);
                logout();
            }

        } else {
            loggedOutView.classList.remove('d-none');
            loggedInView.classList.add('d-none');
        }
    });

    // (페이지 로드 시) 기존 알림 목록을 가져오는 함수
    async function initializeNotifications() {
        try {
            const response = await fetchWithAuth('/api/notifications');
            if (!response.ok) throw new Error('알림 목록 로딩 실패');

            const result = await response.json();
            updateNotificationUI(result.data);

            // 초기 읽지 않은 알림 개수를 계산하고 배지 업데이트
            unreadCount = result.data.filter(n => !n.isRead).length;
            updateUnreadCountBadge();

        } catch (error) {
            console.error("알림 초기화 실패:", error);
        }
    }

    // (페이지 로드 시) 실시간 알림(SSE) 연결을 시작하는 함수
    function connectSSE() {
        const token = localStorage.getItem('accessToken');
        if (!token) return;

        const eventSource = new EventSource(`/api/notifications/subscribe?token=${token}`);

        // 서버에서 보낸 connect 이벤트를 수신하는 리스너
        eventSource.addEventListener("connect", function(event) {
            console.log("서버로부터 연결 확인:", event.data);
        });

        // 알림 이벤트를 수신하는 리스너
        eventSource.addEventListener("notification", function(event) {
            //  서버에서 오는 데이터가 JSON이 아닌 경우 방지를 위해  try-catch 사용
            try {
                const newNotification = JSON.parse(event.data);
                console.log("새 알림 도착:", newNotification);
                prependNotification(newNotification);

                // 새 알림 도착 시 개수 증가 및 배지 업데이트
                unreadCount++;
                updateUnreadCountBadge();

            } catch (e) {
                // 예기치 못한 비-JSON 데이터 수신 시 로그 기록
                console.warn("수신된 데이터가 JSON 형식이 아닙니다:", event.data);
            }
        });

        eventSource.onerror = function(error) {
            console.error("SSE Error:", error);
            eventSource.close();
        };
    }

    // (UI 헬퍼) 알림 목록 전체를 UI에 그리는 함수
    function updateNotificationUI(notifications) {
        const list = document.getElementById('notification-list');

        const itemsToRemove = list.querySelectorAll('li:not(:first-child):not(:nth-child(2))');
        itemsToRemove.forEach(item => item.remove());

        if (!notifications || notifications.length === 0) {
            list.insertAdjacentHTML('beforeend', '<li><p class="dropdown-item text-center text-muted mb-0">알림이 없습니다.</p></li>');
            return;
        }

        const notificationsHtml = notifications.map(createNotificationItemHTML).join('');
        list.insertAdjacentHTML('beforeend', notificationsHtml);
    }

    // (UI 헬퍼) 새 알림을 목록 맨 위에 추가하는 함수
    function prependNotification(notification) {
        const list = document.getElementById('notification-list');
        const noNotiMessage = list.querySelector('p');
        if (noNotiMessage) {
            noNotiMessage.parentElement.remove();
        }
        list.querySelector('hr.dropdown-divider').insertAdjacentHTML('afterend', createNotificationItemHTML(notification));
    }

    // (UI 헬퍼) 알림 항목 1개의 HTML 코드를 생성하는 함수
    function createNotificationItemHTML(notification) {
        const isUnreadClass = notification.isRead ? '' : 'fw-bold';
        const readStatusClass = notification.isRead ? '' : 'd-none';
        const timeAgo = formatTimeAgo(new Date(notification.createdAt));

        return `
            <li>
                <a class="dropdown-item ${isUnreadClass}" href="#" data-notification-id="${notification.id}" onclick="handleNotificationClick(event)">
                    <div class="d-flex w-100 justify-content-between align-items-center">
                        <div class="me-2">
                            <small>${notification.message}</small>
                            <span class="read-status text-muted small ms-1 ${readStatusClass}">(읽음)</span>
                        </div>
                        <small class="text-muted text-nowrap">${timeAgo}</small>
                    </div>
                </a>
            </li>`;
    }

    // (이벤트 핸들러) 알림 항목을 클릭했을 때 '읽음' 처리하는 함수
    async function handleNotificationClick(event) {
        event.preventDefault();
        const target = event.currentTarget;
        const notificationId = target.dataset.notificationId;

        if (!target.classList.contains('fw-bold')) return;

        try {
            const response = await fetchWithAuth(`/api/notifications/${notificationId}/read`, {
                method: 'PATCH',
            });
            if (!response.ok) throw new Error('읽음 처리 실패');

            target.classList.remove('fw-bold');

            unreadCount--;
            updateUnreadCountBadge();

            const readStatusSpan = target.querySelector('.read-status');
            if (readStatusSpan) {
                readStatusSpan.classList.remove('d-none');
            }

        } catch (error) {
            console.error("알림 읽음 처리 실패:", error);
        }
    }
    async function handleMarkAllAsRead(event) {
        event.preventDefault();
        if (unreadCount === 0) return; // 읽을 알림이 없으면 중단

        try {
            const response = await fetchWithAuth('/api/notifications/read-all', {
                method: 'PATCH'
            });
            if (!response.ok) throw new Error('모두 읽음 처리 실패');

            // UI 즉시 업데이트
            unreadCount = 0;
            updateUnreadCountBadge();

            // 모든 알림 항목에서 'fw-bold' 클래스 제거
            document.querySelectorAll('#notification-list .dropdown-item.fw-bold').forEach(item => {
                item.classList.remove('fw-bold');
            });

            // 모든 알림 항목에 '(읽음)' 표시
            document.querySelectorAll('#notification-list .read-status.d-none').forEach(span => {
                span.classList.remove('d-none');
            });

        } catch (error) {
            console.error("모두 읽음 처리 실패:", error);
            alert(error.message || '모두 읽음 처리에 실패했습니다.');
        }
    }

    //  읽지 않은 알림 개수 배지를 업데이트하는 함수
    function updateUnreadCountBadge() {
        const badge = document.getElementById('notification-count-badge');
        const markAllBtn = document.getElementById('mark-all-as-read-btn');

        if (unreadCount > 0) {
            badge.textContent = unreadCount;
            badge.classList.remove('d-none');
        } else {
            badge.classList.add('d-none');
        }
    }

    // (유틸리티) '몇 분 전' 같은 시간 포맷을 만들어주는 함수
    function formatTimeAgo(date) {
        const seconds = Math.floor((new Date() - date) / 1000);
        let interval = seconds / 31536000;
        if (interval > 1) return Math.floor(interval) + "년 전";
        interval = seconds / 2592000;
        if (interval > 1) return Math.floor(interval) + "달 전";
        interval = seconds / 86400;
        if (interval > 1) return Math.floor(interval) + "일 전";
        interval = seconds / 3600;
        if (interval > 1) return Math.floor(interval) + "시간 전";
        interval = seconds / 60;
        if (interval > 1) return Math.floor(interval) + "분 전";
        return "방금 전";
    }
</script>

</body>
</html>