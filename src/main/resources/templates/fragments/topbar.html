<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<body>

<div th:fragment="topbar" class="top-bar bg-white border-bottom shadow-sm">
    <!-- 왼쪽: 홈으로 가는 링크 -->
    <div>
        <a href="/" class="navbar-brand">
            <strong>🎓 강의실 예약 시스템</strong>
        </a>
    </div>

    <!-- 오른쪽: 사용자 관련 버튼들을 담는 컨테이너 -->
    <div class="d-flex align-items-center">
        <!-- 로그아웃 상태일 때 보여줄 뷰 -->
        <div id="logged-out-view">
            <a href="/login" class="btn btn-primary">로그인</a>
            <a href="/signup" class="btn btn-secondary ms-2">회원가입</a>
        </div>

        <!-- 로그인 상태일 때 보여줄 뷰 -->
        <div id="logged-in-view" class="d-flex align-items-center d-none">
            <span class="me-3">환영합니다, <strong id="username-display"></strong>님!</span>
            <a id="admin-page-btn" href="/admin/main" class="btn btn-warning btn-sm me-2 d-none">관리자 페이지</a>
            <button id="logout-button" class="btn btn-outline-danger btn-sm">로그아웃</button>

            <!-- 알림 드롭다운 UI -->
            <div class="notification dropdown ms-2">
                <button class="btn btn-outline-secondary btn-sm position-relative" type="button" id="notification-dropdown-btn" data-bs-toggle="dropdown" aria-expanded="false">
                    🔔
                    <span class="position-absolute top-0 start-100 translate-middle badge rounded-pill bg-danger d-none" id="notification-count-badge">
                        0
                    </span>
                </button>
                <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="notification-dropdown-btn" id="notification-list" style="width: 350px; max-height: 400px; overflow-y: auto;">
                    <li><p class="dropdown-item text-center text-muted mb-0">알림이 없습니다.</p></li>
                </ul>
            </div>
        </div>
    </div>
</div>


<script th:fragment="topbar-script">
    // 읽지 않은 알림 개수를 추적하는 전역 변수
    let unreadCount = 0;

    document.addEventListener('DOMContentLoaded', function() {
        const token = localStorage.getItem('accessToken');
        const loggedOutView = document.getElementById('logged-out-view');
        const loggedInView = document.getElementById('logged-in-view');

        if (token) {
            // UI 상태 변경
            loggedOutView.classList.add('d-none');
            loggedInView.classList.remove('d-none');

            try {
                const payload = parseJwt(token);
                document.getElementById('username-display').textContent = payload.name || '사용자';
                if (payload.role === 'ROLE_ADMIN') {
                    document.getElementById('admin-page-btn').classList.remove('d-none');
                }
            } catch (e) {
                console.error("토큰 파싱 오류:", e);
                logout();
                return;
            }

            // 로그인 상태일 때만 알림 기능 자동 실행
            initializeNotifications();
            connectSSE();

        } else {
            loggedOutView.classList.remove('d-none');
            loggedInView.classList.add('d-none');
        }

        const logoutButton = document.getElementById('logout-button');
        if (logoutButton) {
            logoutButton.addEventListener('click', logout);
        }
    });

    // 1. (페이지 로드 시) 기존 알림 목록을 가져오는 함수
    async function initializeNotifications() {
        try {
            const response = await fetch('/api/notifications', {
                headers: { 'Authorization': `Bearer ${localStorage.getItem('accessToken')}` }
            });
            if (!response.ok) throw new Error('알림 목록 로딩 실패');

            const result = await response.json();
            updateNotificationUI(result.data);

            // 초기 읽지 않은 알림 개수를 계산하고 배지 업데이트
            unreadCount = result.data.filter(n => !n.isRead).length;
            updateUnreadCountBadge();

        } catch (error) {
            console.error("알림 초기화 실패:", error);
        }
    }

    // 2. (페이지 로드 시) 실시간 알림(SSE) 연결을 시작하는 함수
    function connectSSE() {
        const token = localStorage.getItem('accessToken');
        if (!token) return;

        const eventSource = new EventSource(`/api/notifications/subscribe?token=${token}`);

        eventSource.addEventListener("notification", function(event) {
            // [수정] 서버에서 오는 데이터가 JSON이 아닐 수도 있으므로 try-catch로 감싸줍니다.
            try {
                const newNotification = JSON.parse(event.data);
                console.log("새 알림 도착:", newNotification);
                prependNotification(newNotification);

                // 새 알림 도착 시 개수 증가 및 배지 업데이트
                unreadCount++;
                updateUnreadCountBadge();
            } catch (e) {
                // JSON 파싱 실패 시, 연결 메시지 등으로 간주하고 에러를 무시하거나 로그만 남깁니다.
                console.log("수신된 비-JSON 메시지 (연결 확인 등):", event.data);
            }
        });

        eventSource.onerror = function(error) {
            console.error("SSE Error:", error);
            eventSource.close();
        };
    }

    // (UI 헬퍼) 알림 목록 전체를 UI에 그리는 함수
    function updateNotificationUI(notifications) {
        // [제거] 문제가 되었던 잘못된 console.log 코드를 제거합니다.
        const list = document.getElementById('notification-list');
        list.innerHTML = '';

        if (!notifications || notifications.length === 0) {
            list.innerHTML = '<li><p class="dropdown-item text-center text-muted mb-0">알림이 없습니다.</p></li>';
            return;
        }

        notifications.forEach(noti => {
            list.innerHTML += createNotificationItemHTML(noti);
        });
    }

    // (UI 헬퍼) 새 알림을 목록 맨 위에 추가하는 함수
    function prependNotification(notification) {
        const list = document.getElementById('notification-list');
        const noNotiMessage = list.querySelector('p');
        if (noNotiMessage) {
            noNotiMessage.parentElement.remove();
        }
        list.insertAdjacentHTML('afterbegin', createNotificationItemHTML(notification));
    }

    // (UI 헬퍼) 알림 항목 1개의 HTML 코드를 생성하는 함수
    function createNotificationItemHTML(notification) {
        const isUnreadClass = notification.isRead ? '' : 'fw-bold';
        const readStatusClass = notification.isRead ? '' : 'd-none';
        const timeAgo = formatTimeAgo(new Date(notification.createdAt));

        return `
            <li>
                <a class="dropdown-item ${isUnreadClass}" href="#" data-notification-id="${notification.id}" onclick="handleNotificationClick(event)">
                    <div class="d-flex w-100 justify-content-between align-items-center">
                        <div class="me-2">
                            <small>${notification.message}</small>
                            <span class="read-status text-muted small ms-1 ${readStatusClass}">(읽음)</span>
                        </div>
                        <small class="text-muted text-nowrap">${timeAgo}</small>
                    </div>
                </a>
            </li>`;
    }

    // (이벤트 핸들러) 알림 항목을 클릭했을 때 '읽음' 처리하는 함수
    async function handleNotificationClick(event) {
        event.preventDefault();
        const target = event.currentTarget;
        const notificationId = target.dataset.notificationId;

        if (!target.classList.contains('fw-bold')) return;

        try {
            const response = await fetch(`/api/notifications/${notificationId}/read`, {
                method: 'PATCH',
                headers: { 'Authorization': `Bearer ${localStorage.getItem('accessToken')}` }
            });
            if (!response.ok) throw new Error('읽음 처리 실패');

            target.classList.remove('fw-bold');

            unreadCount--;
            updateUnreadCountBadge();

            const readStatusSpan = target.querySelector('.read-status');
            if (readStatusSpan) {
                readStatusSpan.classList.remove('d-none');
            }

        } catch (error) {
            console.error("알림 읽음 처리 실패:", error);
        }
    }

    //  읽지 않은 알림 개수 배지를 업데이트하는 함수
    function updateUnreadCountBadge() {
        const badge = document.getElementById('notification-count-badge');
        if (unreadCount > 0) {
            badge.textContent = unreadCount;
            badge.classList.remove('d-none');
        } else {
            badge.classList.add('d-none');
        }
    }

    // (유틸리티) '몇 분 전' 같은 시간 포맷을 만들어주는 함수
    function formatTimeAgo(date) {
        const seconds = Math.floor((new Date() - date) / 1000);
        let interval = seconds / 31536000;
        if (interval > 1) return Math.floor(interval) + "년 전";
        interval = seconds / 2592000;
        if (interval > 1) return Math.floor(interval) + "달 전";
        interval = seconds / 86400;
        if (interval > 1) return Math.floor(interval) + "일 전";
        interval = seconds / 3600;
        if (interval > 1) return Math.floor(interval) + "시간 전";
        interval = seconds / 60;
        if (interval > 1) return Math.floor(interval) + "분 전";
        return "방금 전";
    }
</script>

</body>
</html>